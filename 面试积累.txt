
1,int a[100]; 里面存放取值范围是0-999的一百个数，其中有两个数是一样的。如何快速找出相同的两个数。
答：建立一个新数组int b[100] = {-1}; 然后轮询一边a[100],令b[0] = 0, b[1] = 1 ...b[n] = n; 一遍轮询结束就能找出重复的数字

2，A城市有20万人，B城市有80万人。一个月内A，B城市总共打了1000万次电话，从概率上求出其中跨城市的通话有多少次。

3, 有一个整数大数组，要找出其中最大的一千个整数
   答1：实例化一个大小是一千的链表，然后将大数组的数据遍历，遍历的数据在链表中排序(插入或者替换)--可选二叉树排序，冒泡排序，希尔排序

4，红黑树(map的存储结构)


7，protobuf 实现的细节
答：传输的报文时按照TLV来传输的(T:type, L:length, V:value)


1，域名怎么解析
2，浏览器怎么访问后端
3，防火墙懂不懂


nginx
redis


算法：

一致性hash

google笔试题:
http://blog.csdn.net/yingxunren/article/details/3968800

类Unix系统的/proc目录
答：http://blog.csdn.net/zdwzzu2006/article/details/7747977

快速排序是怎么实现的？快速排序是稳定的吗？
答：排序算法稳定定义是:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。

问：找出一个字符串最长不重复子串
答：

STL:
set(红黑树) map(红黑树) hash_map(哈希桶) 
vector在插入扩容的时候，iterator有可能会失效，set和map则不会

awk sed命令


1，单向链表，高效取中间节点
   使用两个指针，一个next两次，另外一个next一次，遍历链表，当快指针到达尾端时，慢指针指向中间节点

2，可靠/不可靠信号

3，如何精准控制程序的cpu占用率
答：见github

4，如何灵活控制tcp连接超时处理
答：http://blog.csdn.net/clirus/article/details/50577352

5，进程间通信有哪些IPC，不同进程使用共享内存，访问地址是否一致？ 答：不一致
答:管道--有关系的进程,例如父子进程才能使用管道通信, 系统调用pipe
   命名管道(FIFO) -- 没关系的进程也可以进行通信，需要关联一个文件，系统调用mkfifo
   XSI IPC(消息队列，信号量，共享存储):
       a),消息队列，信号量，共享存储对应的创建系统调用：msgget, semget shmget
       b),XSI IPC在操作系统内核有一个IPC标识符(一个会自增的整数, 针对内核),这个标识符关联一个key_t类型的键。所以创建ipc实例后需要保存键相关信息，方便进程间互相通信。相关生成key_t的系统调用ftok。
       c),ipcs -l用于查看XSI IPC的系统限制
       d),XSI IPC不使用文件描述符，不能使用select或者poll来进行监听。 并且XSI IPC跟进程的关系是独立，必须显式销毁，否则会一直存在。
       e),共享内存性能最好，因为跟用户程序交互一次数据，只需要两次拷贝，而其它ipc需要4次。
       f),信号量(semget)是一个计数器，可用于控制多进程对共享内存对象的访问。 vs 记录锁也可以用于控制多进程共享资源。记录锁性能比信号量差，但如果只需要共享一个资源，宁愿使用记录锁，理由是记录锁简单，并且进程终止系统会自动释放锁。
       g）共享存储实现原理：首先新建一段共享内存，然后将共享内存通过shmat(底层调用mmap)关联到进程的某一个虚拟地址上, 使用完毕调用shmdt取消关联。


6，共享内存在系统内的实现(linux 内核)：
   答：a)shmget通过指定key在内核的虚拟文件系统tmpfs(基于内存，机器重启会丢失)创建一个文件(命名跟key关联)， 改文件(内存)就是分配好的共享内存。
      b)进程通过mmap映射进程本身的虚拟地址到共享内存地址，从而达到访问共享内存的目的。
      c)内存不够用时，共享内存的page cache不能直接丢弃，而是要swap out。

7，进程存储空间
  a) c程序的存储空间布局：
     命令行参数和环境变量
     栈    局部const变量放在这里
     堆    new处理的
     未初始化数据: 全局|局部静态变量 + 全局变量 
     初始化数据：  全局|局部静态变量 + 全局变量
     代码：只读，共享的，全局const 变量放在这里。

8，多线程
   a)vs进程，共享存储地址空间和文件描述符，线程可以合理利用多核cpu。
   b)线程相关的内容：线程ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errnor变量以及线程私有数据。pthread_equal(pthread_t tid1, pthread_t tid2)--线程id进行比较。 pthread_self()--获取线程id
   c)线程同步：
       1)进程修改变量i经历过程如下：读取i放入寄存器 -》 寄存器内容加1 -》把寄存器内存写回i。由于操作系统的设计，这个并非一个原子操作。这个问题引申出多线程处理需要引入同步机制，否则会导致不可预测的结果。
       2)互斥量：
           pthread_mutex_t结构体，系统调用pthread_mutex_lock pthread_mutex_trylock  pthread_mutex_unlock。同一时间只有一个资源能够获取锁。 线程a占有互斥量a_lock, 等待互斥量b_lock,同时线程b占有互斥量b_lock，等待互斥量a_lock, 这时会引起死锁。
           状态只有两个，要么锁住，要不没加锁
       3)读写锁(共享独占锁)：
           状态有三个：读模式下加锁，写模式下加锁，不加锁
           一次只能一个线程占用写模式的读写锁，但是多个线程可以同时占有读模式锁。
           线程希望以写锁模式对一个共享独占锁加锁，必须要等待该锁的所有读锁都释放后，才能成功。同时尝试加写锁会，改锁会拒绝后续的读锁加锁(避免写锁无期限等待)。
           适用于对数据结构读次数远大于写次数的情况。
           系统调用：pthread_rwlock_rdlock|pthread_rwlock_wrlock()|pthread_rwlocak_unlock|trylock系统调用
      4)条件变量(可以跟互斥量配合使用)：
         系统调用：pthread_cond_init|pthread_cond_destroy|pthread_cond_wait|pthread_cond_timewait|pthread_cond_signal|pthread_cond_broadcast
         线程与信号：每个线程都有自己的信号屏蔽字

9，TCP滑动窗口的作用(tcp相关的所有知识，滑动窗口，拥塞窗口，三次握手，四次挥手，状态迁移(time_wait close_wait))

10，stl 如何删除vector里面的元素

11, 信号
    a)alarm产生闹钟信号SIGALRM。
    b)不可靠信号：一个信号发生了，但是进程却一直不知道。后来内核升级优化产生了可靠信号。
    c)Linux 在SIGRTMIN(34)实时信号之前的都叫不可靠信号

c++相关:
1，const成员变量
答：1,只能在构造函数内初始化；
2，赋值构造函数
答：
3，static变量跟全局变量的区别
答：static变量的作用域限定在文件；全局变量可以跨文件(模块)调用(需要加extern)；
4，类菱形继承
答：导致二义性
5，空类大小是多少个字节
答：1个字节。
6，什么叫内联函数，跟宏有什么区别
7，是否所有操作符都可以重载
答：不是，有些可以，有些不可以。C++不能重载的运算符有五个（1） "."（成员访问运算符） （2）" .*"（成员指针访问运算符） （3） "::"（域运算符） （4）"siezof"（长度运算符） （5） " ?:"（条件运算符）. 
8，const函数跟非const函数是否可以构成重载
答：可以，因为函数隐藏参数类型不一致
9，const对象是否只能访问const成员变量
答：不对，可以访问非const成员变量，但是不能修改。不能调起非const函数(主要因为函数会隐藏传达一个this指针)。
10，c++多态

11, restrict，C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。

mysql相关：
1，mysql单机qps
2，mysql引擎相关
3，mysql索引原理

问：mysql的单机qps大概是多少
答：mysql单实例qps大概1000以内，并且由于MySQL很多引擎的索引都是用b+树，所以表大小对qps和tps的影响不算很大(百万级别和千万级别的数据差别不大)，但是如果超过千万级别或者上亿就要考虑分区分表了。

系统相关：
1，稳定信号和不稳定信号的区别

2，僵尸进程是如何产生的？
答:一个子进程结束了，但是父进程没有调用wait/waitpid等待它返回，就会产生僵尸进程，如果父进程先退出，则不会产生僵尸进程。但是子进程会变成孤儿进程，被init进程接管。

3，观察linux一个后台服务，你会关注那些性能指标。(top, free等)
  top里面每一项指标说明，free里面cache和buffer的区别
答：1，cpu：top, cpu占比为（用户态cpu时长+系统态cpu时长)/进程启动总时长
   2，内存：top(RES才是真正的内存), free中buffer和cache的区别：https://www.cnblogs.com/chenpingzhao/p/5161844.html    buffer(写磁盘缓存，内存和磁盘间的缓存，将要写入磁盘)  cache(cpu高速缓存，cpu和内存间的缓存，将要从(内存|磁盘)读入数据)
   3，磁盘io： iostat(关注iowait参数) iotop
   4，系统负载(load average)： http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html, 超过1，表示有进程在等待cpu处理
   5，网络io：
4，connect超时如何解决
答： http://blog.csdn.net/clirus/article/details/50577352 两种解决方案(一，使用select设置超时； 二，使用信号超时)
5，

nosql缓存相关：
如果是多写少读，应该如何选型nosql缓存
      少写多读呢
少写多读可以考虑：
主备集群方案：选举出一台主机，负责写入数据，然后同步到所有备机，读的时候可以用任何一台机器读

多写少读方案：
分片集群方案，twemproxy代理(性能损耗20%)+redis|memcache|ssdb


找时间看一点设置模式相关的书


作者：雨baby
链接：https://www.nowcoder.com/discuss/1864
来源：牛客网

015校招网易C/C++工程师笔试题（附答案）

1.?#include?<?filename.h?>和#i?nclude?“filename.h”?有什么区别??? 答：对于#i?nclude?<?filename.h?>，编译器从标准库路径开始搜索filename.h??
???????对于#i?nclude?“filename.h”，编译器从用户的工作路径开始搜索filename.h 2.?在C++?程序中调用被C?编译器编译后的函数，为什么要加extern?“C”??? 答：C++语言支持函数重载，C?语言不支持函数重载。函数被C++编译后在库中的名字与C?语言的不同。假设某个函数的原型为：
?????????????????????????????????void?foo(int?x,?int?y);??
该函数被C?编译器编译后在库中的名字为_foo?，?而C++?编译器则会产生像_foo_int_int?之类的名字。??
C++提供了C?连接交换指定符号extern“C”来解决名字匹配问题。? 3.?一个类有基类、内部有一个其他类的成员对象，构造函数的执行顺序是怎样的??? 答：先执行基类的(如果基类当中有虚基类，要先执行虚基类的，其他基类则按照声明派生类时的顺序依次执行)，再执行成员对象的，最后执行自己的。 4.?New?delete?与malloc?free?的区别?? 答：用malloc?函数不能初始化对象，new?会调用对象的构造函数。Delete?会调用对象的destructor，而free?不会调用对象的destructor.?? 5.?Struct?和class?的区别?? 答：struct?中成员变量和成员函数默认访问权限是public,class?是private? 6.请问下面程序有什么错误???
int?a[60][250][1000],i,j,k;??
for(k=0;k<=1000;k++)??
for(j=0;j<250;j++)??
for(i=0;i<60;i++)??
a[i][j][k]=0;?? 答：把循环语句内外换一下 7.?请写出下列代码的输出内容  8.?写出BOOL,int,float,指针类型的变量a?与零的比较语句。?? 答：?BOOL?:?if?(?!a?)
??int?:?if?(?a?==?0)
??float?:?const?EXPRESSION?EXP?=?0.000001
??if?(?a?<?EXP?&&?a?>-EXP)
??pointer?:?if?(?a?!=?NULL) 9.已知strcpy?函数的原型是： ??char?*strcpy(char?*strDest,?const?char?*strSrc); 其中strDest?是目的字符串，strSrc?是源字符串。不调用C++/C?的字符串库函数，请编写函数?strcpy 答：  10.写一个函数找出一个整数数组中，第二大的数。 答：  
网易游戏2015
