
1,int a[100]; 里面存放取值范围是0-99的一百个数，其中有两个数是一样的。如何快速找出相同的两个数。
答：建立一个新数组int b[100] = {-1}; 然后轮询一边a[100],令b[0] = 0, b[1] = 1 ...b[n] = n; 一遍轮询结束就能找出重复的数字

2，A城市有20万人，B城市有80万人。一个月内A，B城市总共打了1000万次电话，从概率上求出其中跨城市的通话有多少次。
   分子：从20万人中选出一个人，从80万人选出一个人。相乘就是跨城通话总数。即20万*80万次 = 160000000000
   分母：从100万人中选出两个人，通过求组合得最大通话数是100万次*(100万-1)/2 = 499999500000
   可以求夸城通话概率约为32%
   所以跨市通话为320万

3, 有一个整数大数组，要找出其中最大的一千个整数
   答1：实例化一个大小是一千的链表，然后将大数组的数据遍历，遍历的数据在链表中排序(插入或者替换)--可选二叉树排序，冒泡排序，希尔排序

4，红黑树(map的存储结构)

5, (1)#define max(a,b) (a)>(b)?(a):(b),以下代码运行结果是（）
   int x = 12;
   int y = 10;
   int z = max(++x, y);
   printf("%d", z);
  答案是14，宏展开后x自加两次
  
 6，无序链表删除重复节点
给定一个无序链表，删除其中重复数字的节点，不得使用临时缓冲区，要求空间复杂度为O(1)
    输入: 1->3->3->2->5->5
    输出: 1->3->2->5


7，protobuf 实现的细节
答：传输的报文时按照TLV来传输的(T:type, L:length, V:value)

8，c++的智能指针
   c++98引入auto_ptr，现在不再推荐使用
   auto_ptr存在缺陷：1）复制或者赋值都会改变资源的所有权； 2）在STL容器中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制和可赋值；3）不支持对象数组的内存管理；
   c++11引入unique_ptr(替代auto_ptr)，share_ptr和weak_ptr。其中unique_ptr(和auto_ptr)存在缺陷：两个智能指针，分别对同一个内存进行reset，由于排他性会导致第一个智能指针变成NULL。share_ptr存在编程陷阱：不允许循环引用(例如类A包括成员share_ptr指针指向类B，类B也包含成员share_ptr指针指向类A，这时会存在内存泄漏)；weak_ptr可以用来解决share_ptr的问题。


###########################其他问题积累
1，域名怎么解析
2，浏览器怎么访问后端
3，防火墙懂不懂
4，tcp长连接心跳问题：
   a)一般使用tcp短连接会存在的问题是:有额外三次握手，四次挥手的时间消耗；tcp慢启动机制会导致无法达到性能最优。
   b)不使用tcp的keepalive机制探测tcp心跳的原因是，从应用层做心跳控制更加可靠。
   c)DHCP机制可能会导致长连接失效，所以设置tcp长连接心跳间隔需要参考DHCP租期(心跳间隔一般需要小于DHCP租期)
   d)除了DCHP机制，NAT网络映射机制也可能会导致TCP长连接失效。
#################################


nginx:
nginx是如何处理惊群事件的:简单来说，nginx通过共享锁，允许同一时间内只有一个worker进程优先在epoll_wait里面处理监听socket句柄的事件(这个时间内会将其它socket句柄的事件延后处理)。
nginx实现多进程负载均衡：每一个进程有一个最大连接数配置，如果进程连接数达到最大配置的7/8，将会暂缓处理accept的操作。
参考：https://blog.csdn.net/russell_tao/article/details/7204260

redis


算法：

1, 一致性hash
2, 有40亿个无符号(有符号)乱序整数的大文件，只使用1g内存，如何将这个文件排序。
   答：(归纳为外排序算法)：
         a）依次读入每个文件块，在内存中对当前文件块进行排序（应用恰当的内排序算法）。此时，每块文件相当于一个由小到大排列的有序队列。
         b）在内存中建立一个最小值堆，读入每块文件的队列头。
         c)弹出堆顶元素，如果元素来自第i块，则从第i块文件中补充一个元素到最小值堆。弹出的元素暂存至临时数组。
         d)当临时数组存满时，将数组写至磁盘，并清空数组内容。
         e)重复过程c）、d），直至所有文件块读取完毕。
3, md5加密是否安全？
   不安全，可以通过md5网站进行反查：http://cmd5.com/
   MD5 是一个经典的 hash 算法，其和 SHA-1 算法都已被 证明 安全性不足应用于商业场景
   

google笔试题:
http://blog.csdn.net/yingxunren/article/details/3968800

类Unix系统的/proc目录
答：http://blog.csdn.net/zdwzzu2006/article/details/7747977

快速排序是怎么实现的？快速排序是稳定的吗？
答：排序算法稳定定义是:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。

问：找出一个字符串最长不重复子串
答：

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = int(s.length()), res = 0;
        unordered_map<char, int> mp;

        for (int j = 0, i = 0; j < n; j++){
            if(mp[s[j]] > 0) {
                i = max(mp[s[j]], i);
            }
            res = max(res, j - i + 1);
            mp[s[j]] = j + 1;
        }
        return res;
    }
};

STL:
set(红黑树) map(红黑树) hash_map(哈希桶) 
vector在插入扩容的时候，iterator有可能会失效，set和map则不会

awk sed命令


1，单向链表，高效取中间节点
   使用两个指针，一个next两次，另外一个next一次，遍历链表，当快指针到达尾端时，慢指针指向中间节点

2，可靠/不可靠信号

3，如何精准控制程序的cpu占用率
答：见github

4，如何灵活控制tcp连接超时处理
答：http://blog.csdn.net/clirus/article/details/50577352

5，进程间通信有哪些IPC，不同进程使用共享内存，访问地址是否一致？ 答：不一致
答:管道--有关系的进程,例如父子进程才能使用管道通信, 系统调用pipe
   命名管道(FIFO) -- 没关系的进程也可以进行通信，需要关联一个文件，系统调用mkfifo
   XSI IPC(消息队列，信号量，共享存储):
       a),消息队列，信号量，共享存储对应的创建系统调用：msgget, semget shmget
       b),XSI IPC在操作系统内核有一个IPC标识符(一个会自增的整数, 针对内核),这个标识符关联一个key_t类型的键。所以创建ipc实例后需要保存键相关信息，方便进程间互相通信。相关生成key_t的系统调用ftok。
       c),ipcs -l用于查看XSI IPC的系统限制
       d),XSI IPC不使用文件描述符，不能使用select或者poll来进行监听。 并且XSI IPC跟进程的关系是独立，必须显式销毁，否则会一直存在。
       e),共享内存性能最好，因为跟用户程序交互一次数据，只需要两次拷贝，而其它ipc需要4次。
       f),信号量(semget)是一个计数器，可用于控制多进程对共享内存对象的访问。 vs 记录锁也可以用于控制多进程共享资源。记录锁性能比信号量差，但如果只需要共享一个资源，宁愿使用记录锁，理由是记录锁简单，并且进程终止系统会自动释放锁。
       g）共享存储实现原理：首先新建一段共享内存，然后将共享内存通过shmat(底层调用mmap)关联到进程的某一个虚拟地址上, 使用完毕调用shmdt取消关联。


6，共享内存在系统内的实现(linux 内核)：
   答：a)shmget通过指定key在内核的虚拟文件系统tmpfs(基于内存，机器重启会丢失)创建一个文件(命名跟key关联)， 改文件(内存)就是分配好的共享内存。
      b)进程通过mmap映射进程本身的虚拟地址到共享内存地址，从而达到访问共享内存的目的。
      c)内存不够用时，共享内存的page cache不能直接丢弃，而是要swap out。

7，进程存储空间
  a) c程序的存储空间布局：
     命令行参数和环境变量
     栈    局部const变量放在这里
     堆    new处理的
     未初始化数据: 全局|局部静态变量 + 全局变量 
     初始化数据：  全局|局部静态变量 + 全局变量
     代码：只读，共享的，全局const 变量放在这里。

8，多线程
   a)vs进程，共享存储地址空间和文件描述符，线程可以合理利用多核cpu。
   b)线程相关的内容：线程ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errnor变量以及线程私有数据。pthread_equal(pthread_t tid1, pthread_t tid2)--线程id进行比较。 pthread_self()--获取线程id
   c)线程同步：
       1)进程修改变量i经历过程如下：读取i放入寄存器 -》 寄存器内容加1 -》把寄存器内存写回i。由于操作系统的设计，这个并非一个原子操作。这个问题引申出多线程处理需要引入同步机制，否则会导致不可预测的结果。
       2)互斥量：
           pthread_mutex_t结构体，系统调用pthread_mutex_lock pthread_mutex_trylock  pthread_mutex_unlock。同一时间只有一个资源能够获取锁。 线程a占有互斥量a_lock, 等待互斥量b_lock,同时线程b占有互斥量b_lock，等待互斥量a_lock, 这时会引起死锁。
           状态只有两个，要么锁住，要不没加锁
       3)读写锁(共享独占锁)：
           状态有三个：读模式下加锁，写模式下加锁，不加锁
           一次只能一个线程占用写模式的读写锁，但是多个线程可以同时占有读模式锁。
           线程希望以写锁模式对一个共享独占锁加锁，必须要等待该锁的所有读锁都释放后，才能成功。同时尝试加写锁会，改锁会拒绝后续的读锁加锁(避免写锁无期限等待)。
           适用于对数据结构读次数远大于写次数的情况。
           系统调用：pthread_rwlock_rdlock|pthread_rwlock_wrlock()|pthread_rwlocak_unlock|trylock系统调用
      4)条件变量(可以跟互斥量配合使用)：
         系统调用：pthread_cond_init|pthread_cond_destroy|pthread_cond_wait|pthread_cond_timewait|pthread_cond_signal|pthread_cond_broadcast
         线程与信号：每个线程都有自己的信号屏蔽字

9，TCP滑动窗口的作用(tcp相关的所有知识，滑动窗口，拥塞窗口，三次握手，四次挥手，状态迁移(time_wait close_wait))

10，stl 如何删除vector里面的元素

11, 信号
    a)alarm产生闹钟信号SIGALRM。
    b)不可靠信号：一个信号发生了，但是进程却一直不知道。后来内核升级优化产生了可靠信号。
    c)Linux 在SIGRTMIN(34)实时信号之前的都叫不可靠信号
 
12，设计模式，共23种
    创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。
    结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
    行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。
    
    
c++相关:
1，const成员变量
答：1,只能在构造函数内初始化；
2，赋值构造函数
答：
3，static变量跟全局变量的区别
答：static变量的作用域限定在文件；全局变量可以跨文件(模块)调用(需要加extern)；
4，类菱形继承
答：导致二义性
5，空类大小是多少个字节
答：1个字节。
6，什么叫内联函数，跟宏有什么区别
7，是否所有操作符都可以重载
答：不是，有些可以，有些不可以。C++不能重载的运算符有五个（1） "."（成员访问运算符） （2）" .*"（成员指针访问运算符） （3） "::"（域运算符） （4）"siezof"（长度运算符） （5） " ?:"（条件运算符）. 
8，const函数跟非const函数是否可以构成重载
答：可以，因为函数隐藏参数类型不一致
9，const对象是否只能访问const成员变量
答：不对，可以访问非const成员变量，但是不能修改。不能调起非const函数(主要因为函数会隐藏传达一个this指针)。
10，c++多态

11, restrict，C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。

12， __attribute__
   1)__attribute__((aligned(4)))改变结构体的内存对齐方式。当然还有其它属性，用到的时候再去调查。
   2)将在函数后面，可以在编译时输出warnning信息，配置编译选项-Wall一起使用。
   3)可以指定一些函数，在main函数之前或者之后执行。并且还可以同时指定多个函数，指定函数执行的优先级。
   
13, mutable
   1)在类里面修饰成员变量，可以在const成员函数中改变改变量的值(const成员函数不能改变其他变量的值)。

mysql相关：
1，mysql单机qps
2，mysql引擎相关
3，mysql索引原理

问：mysql的单机qps大概是多少
答：mysql单实例qps大概1000以内，并且由于MySQL很多引擎的索引都是用b+树，所以表大小对qps和tps的影响不算很大(百万级别和千万级别的数据差别不大)，但是如果超过千万级别或者上亿就要考虑分区分表了。

4, mysql的mvcc
  a) 什么是mvcc:MVCC (Multiversion Concurrency Control),即多版本并发控制技术,它使得大部分支持行锁的事务引擎,不再单纯的使用行锁来进行数据库的并发控制,取而代之的是,把数据库的行锁与行的多个版本结合起来,只需要很小的开销,就可以实现非锁定读,从而大大提高数据库系统的并发性能.

系统相关：
1，稳定信号和不稳定信号的区别

2，僵尸进程是如何产生的？
答:一个子进程结束了，但是父进程没有调用wait/waitpid等待它返回，就会产生僵尸进程，如果父进程先退出，则不会产生僵尸进程。但是子进程会变成孤儿进程，被init进程接管。

3，观察linux一个后台服务，你会关注那些性能指标。(top, free等)
  top里面每一项指标说明，free里面cache和buffer的区别
答：1，cpu：top, cpu占比为（用户态cpu时长+系统态cpu时长)/进程启动总时长
   2，内存：top(RES才是真正的内存), free中buffer和cache的区别：https://www.cnblogs.com/chenpingzhao/p/5161844.html    buffer(写磁盘缓存，内存和磁盘间的缓存，将要写入磁盘)  cache(cpu高速缓存，cpu和内存间的缓存，将要从(内存|磁盘)读入数据)
   3，磁盘io： iostat(关注iowait参数) iotop
   4，系统负载(load average)： http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html, 超过1，表示有进程在等待cpu处理
   5，网络io：
4，connect超时如何解决
答： http://blog.csdn.net/clirus/article/details/50577352 两种解决方案(一，使用select设置超时； 二，使用信号超时)
5，

nosql缓存相关：
如果是多写少读，应该如何选型nosql缓存
      少写多读呢
少写多读可以考虑：
主备集群方案：选举出一台主机，负责写入数据，然后同步到所有备机，读的时候可以用任何一台机器读

多写少读方案：
分片集群方案，twemproxy代理(性能损耗20%)+redis|memcache|ssdb


找时间看一点设置模式相关的书

加密相关：
   非对称加密算法：rsa
   对称加密算法：DES
   DH密钥交换:
   


作者：雨baby
链接：https://www.nowcoder.com/discuss/1864
来源：牛客网

015校招网易C/C++工程师笔试题（附答案）

1.?#include?<?filename.h?>和#i?nclude?“filename.h”?有什么区别??? 答：对于#i?nclude?<?filename.h?>，编译器从标准库路径开始搜索filename.h??
???????对于#i?nclude?“filename.h”，编译器从用户的工作路径开始搜索filename.h 2.?在C++?程序中调用被C?编译器编译后的函数，为什么要加extern?“C”??? 答：C++语言支持函数重载，C?语言不支持函数重载。函数被C++编译后在库中的名字与C?语言的不同。假设某个函数的原型为：
?????????????????????????????????void?foo(int?x,?int?y);??
该函数被C?编译器编译后在库中的名字为_foo?，?而C++?编译器则会产生像_foo_int_int?之类的名字。??
C++提供了C?连接交换指定符号extern“C”来解决名字匹配问题。? 3.?一个类有基类、内部有一个其他类的成员对象，构造函数的执行顺序是怎样的??? 答：先执行基类的(如果基类当中有虚基类，要先执行虚基类的，其他基类则按照声明派生类时的顺序依次执行)，再执行成员对象的，最后执行自己的。 4.?New?delete?与malloc?free?的区别?? 答：用malloc?函数不能初始化对象，new?会调用对象的构造函数。Delete?会调用对象的destructor，而free?不会调用对象的destructor.?? 5.?Struct?和class?的区别?? 答：struct?中成员变量和成员函数默认访问权限是public,class?是private? 6.请问下面程序有什么错误???
int?a[60][250][1000],i,j,k;??
for(k=0;k<=1000;k++)??
for(j=0;j<250;j++)??
for(i=0;i<60;i++)??
a[i][j][k]=0;?? 答：把循环语句内外换一下 7.?请写出下列代码的输出内容  8.?写出BOOL,int,float,指针类型的变量a?与零的比较语句。?? 答：?BOOL?:?if?(?!a?)
??int?:?if?(?a?==?0)
??float?:?const?EXPRESSION?EXP?=?0.000001
??if?(?a?<?EXP?&&?a?>-EXP)
??pointer?:?if?(?a?!=?NULL) 9.已知strcpy?函数的原型是： ??char?*strcpy(char?*strDest,?const?char?*strSrc); 其中strDest?是目的字符串，strSrc?是源字符串。不调用C++/C?的字符串库函数，请编写函数?strcpy 答：  10.写一个函数找出一个整数数组中，第二大的数。 答：  
网易游戏2015


http协议：
1，http头：
   *http chunk请求:
   *HTTP/1.1 协议Expect: 100-continue  ：
   
   

*精通C/C++或java或php语言,至少了解另外一种主流开发语言
done
*熟练掌握javascript,ajax，能够设计组件和开发框架
done
*精通面向对象建模技术
TODO
*熟悉UML中的用例、类目、序列图的用法，并在系统设计中灵活运用
TODO
*熟练掌握的html语法
TODO
*熟悉常用的页面性能优化的方法，并在系统架构设计中矛以考虑配合前端优化网页性能
TODO
*精通shell编写
done
*精通进程及线程的优缺点
done
*精通tcp/ip
done
*精通http协议
done
*掌握ftp、pop3、smtp协议
TODO
*了解3dns
TODO
*熟悉数据库维护、优化、备份
TODO
*熟悉高性能数据库设计
TODO
*熟悉linux内核参数的意义及配置
TODO
*熟悉linux文件系统
TODO


x509证书相关：
https://zhuanlan.zhihu.com/p/36832100
